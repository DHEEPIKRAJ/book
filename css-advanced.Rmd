# More CSS

The previous chapter explained the basic syntax and usage of CSS, enough to let you create and style your own web pages. This chapter provides more details about additional selectors and properties to use when defining CSS rules; the following chapter discusses particular properties that can be used to further style the layout of your page's content.

## Compound Selectors

As described in the previous chapter, the core selectors used in CSS are the **element selector**, **class selector**, and **id selector**. However, CSS does offer ways to combine these selectors in order to specify rules only for particular elements or groups of elements.

### Group Selector {-}
The **group selector** allows you to have a single rule apply to elements matched by lots of different selectors. To do this, separate each selector with a comma (**`,`**); the properties defined in the rule will then apply to any element that is matched by _any_ of the selectors. For example, if you want to have a single style for all headings, you might use:

```css
/* applies to h1, h2, AND h3 tags */
h1, h2, h3 {
    font-family: Helvetica;
    color: #4b2e83; /* UW purple */
}
```

The comma-separated selectors can by **any** kind of selector, including `.class` or `#id` selectors (or any of the combound selectors described below):

```css
/* can also include class or id selectors */
/* this rule applies to h2 elements, "menu" classed elements, and the
   #sidebar element */
h2, .menu, #sidebar {
    background-color: gray;
}
```

Note that since later rules earlier ones, you can use a group select to apply a property to multiple different element, but then include additional rules to add variations. For example, you can have one rule that applies "general" styling to a large class of elements, whith further rules then customizing particular elements.

```css
/* all headings are Helvetica, bold, and purple */
h1, h2, h3 {
    font-family: Helvetica;
    font-weight: bold;
    color: #4b2e83; /* UW purple */
}

/* h2 elements are not bolded, but italic */
h2 {
    font-weight: normal; /* not bold, overrides previous rule */
    font-style: italic;
}
```


### Combined Selectors {-}
It is also possible to combine element, class, and id selectors together to be more specific about where a rule applies. You do this by simply putting the class or id selector _immediately after_ the previous selector, without a comma or space or anything between them:

```css
/* Selects only p elements that have class="alert"
   Other p elements and "alert" classed elements not affected */
p.alert {
  color: red;
}

/* Selects only h1 elements that have id="title" */
/* Note that this is redundant, since only one element can have the id! */
h1#title {
  color: purple;
}

/* Selects elements that have class "alert" AND class "success" */
.alert.success {
  color: green;
  font-size: larger;
}

/* And can combine with group selector */
/* applies to <p class="highlighted"> and <li class="selected"> */
p.highlighted, li.marked {
  background-color: yellow;
}
```

This specificity can allow you to reuse class names (e.g., for shared semantics and readability purposes) but have them work differently for different elements. So a "highlighted" paragraph `p.highlighted` might look different than a "highlighted" heading `h1.highlighted`.

Note that putting a space between the selectors parts instead specifies a **descendant selector**, which has a totally separate meaning. Every character matters!

### Descendant Selector {-}
So far, all selectors mentioned will apply to matching elements regardless of where they are in the HTML element tree. But sometimes you want to be more specific and style only a set of elements that exist within a particular parent or ancestor element, and not all the other matching elements elsewhere in the page. You can do this form of targeted selecting using a **descendant selector**. This is written by putting a blank space (**<code>&nbsp;</code>**) between selectors. Elements are only selected if they have _parents that match the selectors that precede them_:

```html
<header>
   <h1>Welcome to the page</h1>
   <p>I am a special paragraph</p>
</header>
<section>
   <p>some other paragraph</p>
</section>
```

```css
/*
  Selects p elements that exist within header elements
  Other p elements will not be affected
 */
header p {
    /* ... */
}
```

You can have as many "levels" of a descendant selector as you want, and each level can be made up of any kind of selector. However, it is best to not have more than 2 or 3 levels. If you need to be more specific than that, then perhaps defining a new `.class` is in order.

```css
/* selects elements with class="logo"
   contained within <p> elements
   contained within <header> elements */
header p .logo {
    /* ... */
}
```

Note that descendant selectors will select matching descendant elements _anywhere_ lower in the tree branch, not just direct children, so the `.logo` elements here could be nested several layers below the `<p>` element (perhaps inside a `<span>`). This is usually a good idea because you may introduce new nesting layers to your page as you go along, and don't want to modify the CSS. But if you really want to select only _direct_ children, you can use a variant known as a **child selector**, which uses a **`>`** symbol to indicate direct descendants only:

```html
<body>
  <p>Body content</p>
  <section>
    <p>Section content</p>
  </section>
</body>
```

```css
/* Selects page content (immediately within body),
   not section content (immediately within section) */
body > p {
  color: blue;
}
```

### Pseudo-classes {-}
The last kind of selector you will commonly use in web development is the application of what are called **pseudo-classes**. These select elements based on what **state** the element is in: for example, whether a link has been visited, or whether the mouse is hovering over some content. You can almost think of these as pre-defined classes built into the browser, that are added and removed as you interact with the page.

Pseudo-classes are written by placing a colon (**`:`**) and the name of the pseudo-class immediately after a basic selector like an element selector. You'll see this most commonly with styling hyperlinks:

```css
/* style for unvisited links */
a:link { /*...*/ }

/* style for visited links */
a:visited { /*...*/ }

/* style for links the user is hovering over with the mouse */
a:hover { /*...*/ }

/* style for links that have keyboard focus */
a:focus { /*...*/ }

/* style for links as they are being 'activated' (clicked) */
a:active { /*...*/ }
```

<p class="alert alert-warning">Remember to always set both `hover` _and_ `focus`, to support accessibility for people who cannot use a mouse. Additionally, `a:hover` _must_ come after `a:link` and `a:visited`, and `a:active` must come after `a:hover` for these states to work correctly.</p>

Note that there are [many additional pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes), including ones that consider specific element attributes (e.g., if a checkbox is `:checked`) or where an element is located within its parent (e.g., if it is the `:first` or `:last-child`, which can be useful for styling lists).

### Attribute Selectors {-}
Finally, it is also possible to select element that have a particular attribute by using an [**attribute selector**](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors). Attribute selectors are written by placing brackets **`[]`** after a basic selector; inside the brackets you list the attribute and value you want to select for using `attribute=value` syntax:

```css
/* select all p elements whose "lang=sp" */
p[lang="sp"] {
    color: red;
    background-color: orange;
}
```

It is also possible to select attributes that only "partially" match a particular value; see the documentation for details.

Note that it is most common to use this selector when styling form inputs; for example, to make checked boxes appear different than unchecked boxes:

```css
/* select <input type="checked"> that have the "checked" state */
input[type=checkbox]:checked {
    color: green;
}
```

## Property Values
This section of the guide provides further details about the possible _values_ that may be assigned to properties in CSS rules. These specifics are often relevant for multiple different properties.

### Units & Sizes {#css-units .unnumbered}
Many CSS properties affect the **size** of things on the screen, whether this is the height of the text (the `font-size`) or the width of a box (the `width`; see the next chapter). In CSS, you can use a variety of different **units** to specify sizes.

CSS uses the following **absolute units**, which are the same no matter where they are used on the page (though they are dependent on the OS and display).

| Unit | Meaning |
| :---------- | :---------------------------------------------------------- |
| `px` | **pixels** ($\frac{1}{96}$ of an inch, even on high-dpi "retina" displays) |
| `in` | **inches** (OS and display dependent, but maps to physical pixels in some way) |
| `cm`, `mm` | centimeters or millimeters, respectively |
| `pt` | points (defined as $\frac{1}{72}$ of an inch) |

Although technically based on `in` as a standard, it is considered best practice to always use `px` for values with absolute units.

CSS also uses the following **relative units**, which will produce sizes based on (relative to) the size of other elements:

| Unit | Meaning |
| :---------- | :---------------------------------------------------------- |
| `em` | Relative to the **current** element's font-size. Although originally a <a href="http://en.wikipedia.org/wiki/Em_(typography)">typographic measurement</a>, this unit will **not** change based on `font-family`. |
| `%` | Relative to the **parent** element's font-size _or_ dimension. For font-size, use `em` instead (e.g., `1.5em` is `150%` the parent font-size). |
| `rem` | Relative to the **root** element's font-size (i.e., the `font-size` of the root `html` or `body` element). This will often be more consistent than `em`. |
| `vw`, `vh` | Relative to the **viewport** (e.g., the browser window). Represents 1% of the viewport width and height, respectively. This unit is not supported [by older browsers](http://caniuse.com/#search=vw). |

Note that most browsers have a default font size of `16px`, so `1em` and `1rem` will both be initially equivalent to `16px`.

In general, you should specify font sizes using _relative units_ (e.g., `em`)&mdash;this will support accessibility, as vision-impaired users will be able to increase the default font-size of the browser and all your text will adjust appropriately. Absolute units are best for things that do not scale across devices (e.g., image sizes, or the maximum width of content). However, using relative sizes will allow those components to scale with the rest of the page.

- Font-sizes should always be relative; layout dimensions may be absolute (but relative units are best).

### Colors {-}
Colors of CSS properties can be specified in a few different ways.

You can use one of a list of 140 [predefined color names](http://www.w3schools.com/cssref/css_colornames.asp):

```css
p {
   color: mediumpurple;
}
```

While this does not offer a lot of flexibility, they can act as useful placeholders and starting points for design. The list of CSS color names also has a [fascinating history](http://arstechnica.com/information-technology/2015/10/tomato-versus-ff6347-the-tragicomic-history-of-css-color-names/).

Alternatively, you can specify a color as a ["red-green-blue"](https://en.wikipedia.org/wiki/RGB_color_model) (RGB) value. This is a way of representing _additive color_, or the color that results when the specified amount of red, green, and blue light are aimed at a white background. RGB values are the most common way of specifying color in computer programs.

```css
p {
   color: rgb(147, 112, 219); /* medium purple */
}
```

This value option is actually a _function_ that takes a couple of parameters representing the amount of red, green, and blue respectively. Each parameter ranges from `0` (none of that color) to `255` (that color at full). Thus `rgb(255,0,0)` is pure bright red, `rgb(255,0,255)` is full red and blue but no green (creating magenta), `rgb(0,0,0)` is black and `rgb(255,255,255)` is white.

Note that if you want to make the color somewhat transparent, you can also specify an [alpha](https://en.wikipedia.org/wiki/Alpha_compositing) value using the `rgba()` function. This function takes a 4th parameter, which is a decimal value from `0` (fully transparent) to `1.0` (fully opaque):

```css
p {
   background-color: rgba(0,0,0,0.5); /* semi-transparent black */
}
```

CSS also [supports](https://developer.mozilla.org/en-US/docs/Web/CSS/color) `hsl()` and `hsla()` functions for specifying color in terms of a [hue, saturation, lightness](https://en.wikipedia.org/wiki/HSL_and_HSV) color model.

Finally, and most commonly, you can specify the RGB value as a [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) (base-16) number.

```css
p {
   color: #9370db; /* medium purple */
}
```

In this format, the color starts with a `#`, the first two characters represent the red (ranging from `00` to `FF`, which is hex for `255`), the second two characters represent the green, and the third two the blue:

![How to reading a hex value, from [Smashing Magazine](https://www.smashingmagazine.com/2012/10/the-code-side-of-color/).](img/css/hex-reading.png)

This is a more compact and efficient way to describe the RGB of a color, and is how most digital artists convey color. See [this article](https://www.smashingmagazine.com/2012/10/the-code-side-of-color/) for more details about encoding colors.

### Fonts and Icons
<!-- serif vs sans-serif -->
<!-- font-awesome -->

### Backgrounds
<!-- using `url()`, etc for images. path issues. reading documentation for options. -->


## Resources {-}
- [CSS Diner](https://flukeout.github.io/) a fun game for practicing with different CSS selectors
- [CSS Units and Values (MDN)](https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Values_and_units)
